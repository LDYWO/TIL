# Execution Context in JavaScript
## 1 실행 컨텍스트
### 1.1 실행 컨텍스트 개념
- 대부분의 프로그래밍 언어에서는 함수를 실행하는 데 있어서 **콜스택 방식**을 채택하고 있다.
- 자바스크립트 또한 콜스택의 범주를 크게 벗어나지 않는다.
- **실행 컨텍스트**는 **콜 스택에 들어가는 실행 정보 하나**와 비슷하다.
- ECMA에서는 실행 컨텍스트를 ```실행 가능한 코드를 형상화하고 구분하는 추상적인 개념```으로 기술한다.
- 이를 콜스택과 연관하여 정의하면 ```실행 가능한 자바스크립트 코드 블록이 실행되는 환경```이라 할 수 있다.
- 대부분의 ```실행 가능한 코드 블록```은 **함수**의 경우이다.
- 대부분의 프로그래머는 함수로 실행 컨텍스트를 만들고 이 코드 블록 안에 변수 및 객체, 실행 가능한 코드를 넣는다.
- 이 코드가 실행되면 실행 컨텍스트가 생성되고, 실행 컨텍스트는 스택 안에 하나씩 차곡차곡 쌓인다.
- 현재 실행되고 있는 컨텍스트는 스택의 가장 위쪽에 위치한다.

#### 1.1.1 ECMA가 규정한 실행 컨텍스트가 형성되는 3가지 경우
  1. 전역 코드
  2. ```eval()``` 함수로 실행되는 코드
  3. 함수 안의 코드를 실행하는 경우

  - 현재 실행되는 컨텍스트에서 **이 컨텍스트와 관련 없는 실행 코드가 실행**되면,
  - **새로운 컨텍스트가 생성되어 스택**에 들어가고 **제어권이 그 컨텍스트로 이동**한다.

```JavaScript
// 1. [ ] --> 전역 컨텍스트 실행 --> [전역 컨텍스트]
console.log("This is global context");

function ExContext1() {
    console.log("This is ExContext1");
} // 4. [전역 컨텍스트 - ExContext2 - ExContext1] --> ExContext1 종료 --> [전역 컨텍스트 - ExContext2]

function ExContext2() {
    ExContext1(); // 3. [전역 컨텍스트 - ExContext2] --> ((ExContext1 호출))  
                  // --> [전역 컨텍스트 - ExContext2 - ExContext1]
    console.log("This is ExContext2");
} // 5. [전역 컨텍스트 - ExContext2] --> ExContext2 종료 --> [전역 컨텍스트]

ExContext2(); // 2. [전역 컨텍스트] --> ((ExContext2 호출)) --> [전역 컨텍스트 - ExContext2]

// 6. [전역 컨텍스트] --> 전역 컨텍스트의 실행 완료 --> [ ]
```
- **전역 실행 컨텍스트가 먼저 실행**된다.
- **새로운 함수 호출**이 발생하면 **새로운 컨텍스트**가 만들어지고 실행되며, **종료되면 반환**된다.
- 이와 같은 과정이 반복된 후, **전역 실행 컨텍스트의 실행이 완료**되면 모든 실행이 끝난다.

### 1.2 실행 컨텍스트 생성 과정
- 주요 개념
    - 활성 객체와 변수 객체
    - 스코프 체인

```JavaScript
function execute(param1, param2) {
    var a = 1;
    var b = 2;

    function func() {
        return a + b;
    }
    return param1 + param2 + func();
}

execute(3, 4);
```

#### 1.2.1 활성 객체 생성
- 실행 컨텍스트가 생성되면 자바스크립트 엔진은 **해당 컨텍스트에서 실행에 필요한 여러 정보를 담을 객체를 생성**한다.
- 이 객체에 앞으로 매개 변수나 사용자가 정의한 변수 및 객체를 저장하고, 새로 만들어진 컨텍스트로 접근 가능하다.
- 이를 **활성 객체** 라고 한다.

#### 1.2.2 arguments 객체 생성
- 다음 단계에서는 arguments 객체를 생성한다.
- 앞서 만들어진 활성 객체는 arguments 프로퍼티로 이 arguments 객체를 참조한다.
- arguments -> [param1, param2]

#### 1.2.3 스코프 정보 생성
- **현재 컨텍스트의 유효 범위**를 나타내는 스코프 정보를 생성한다.
- 이 스코프 정보는 현재 실행 중인 **실행 컨텍스트 안에서 연결 리스트와 유사한 형식**으로 만들어진다.
- **현재 컨텍스트에서 특정 변수에 접근해야 할 경우**, 이 연결 리스트를 활용한다.
- **이 연결 리스트를 통해** 현재 컨텍스트의 변수 뿐 아니라, **상위 실행 컨텍스트의 변수도 접근이 가능**하다.
- **이 리스트에서 찾지 못한 변수**는 결국 정의되지 않은 변수에 접근하는 것으로 판단하여 **에러를 검출**한다.
- 이 리스트를 **스코프 체인**이라 하는데, ```[[scope]]``` 프로퍼티로 참조된다.
- 현재 생성된 **활성 객체**가 스코프 체인의 제일 앞에 추가되며, ```execute()``` **함수의 인자나 지역 변수 등에 접근**할 수 있다.

#### 1.2.4 변수 생성
- 현재 실행 컨텍스트 내부에서 사용되는 **지역 변수의 생성**이 이루어진다.
- 실제적으로 앞서 생성된 **활성 객체**가 ECMA에서 언급한 변수를 저장하는 **변수 객체**와 같은 단어이다.
- 변수 객체 안에서 **호출된 함수 인자는 각각의 프로퍼티**가 만들어지고 **그 값이 할당**된다.
- 값이 넘겨지지 않았다면 ```undefined```가 할당된다.
- 예제에서 ```execute()``` 함수 안에 정의된 변수 ```a, b, func``` 가 생성된다.
- 이 과정에서는 **변수나 함수를 단지 메모리에 생성하기만 할 뿐**이다.
- **초기화는 각 변수나 함수에 해당하는 표현식이 실행되기 전까지는 이루어지지 않는다.**
- 따라서, **변수 a와 b에는 먼저 ```undefined```가 할당되고, 표현식의 실행은 변수 객체 생성이 다 이루어진 후 시작된다.**

#### 1.2.5 this 바인딩
- 마지막 단계에서는 ```this``` 키워드를 사용하는 값이 할당된다.
- 여기서 ```this```가 참조하는 객체가 없으면 전역 객체를 참조한다.

#### 1.2.6 코드 실행
- 이렇게 하나의 실행 컨텍스트가 생성되고, 변수 객체가 만들어진 후에, 코드에 있는 여러가지 표현식 실행이 이루어진다.
- 이렇게 실행되면서 변수의 초기화 및 연산, 또 다른 함수의 실행 등이 이루어진다.

  ##### 전역 실행 컨텍스트
  - **일반적인 실행 컨텍스트**와는 약간 다르다.
  - ```arguments``` 객체가 없다.
  - 전역 객체 하나만을 포함하는 **스코프 체인**이 있다.
  - 전역 코드가 실행될 때 생성되는 **컨텍스트**이다.
  - 변수를 초기화하고 이것의 내부 함수는 일반적인 **탑 레벨의 함수**로 선언된다.
  - 전역 실행 컨텍스트의 **변수 객체**가 곧 **전역 객체**로 사용된다.
  - 따라서, **전역적으로 선언된 함수와 변수**가 **전역 객체의 프로퍼티**가 되며 ```this```를 **전역 객체의 참조**로 사용한다.
