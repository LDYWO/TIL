# Abstract Class VS Interface
## 1. 추상클래스 (Abstract Class)
> 기존의 클래스에서 공통된 부분을 추상화하여 상속하는 클래스에게 구현을 강제화
> 메소드의 동작을 구현하는 자식클래스로 책임을 위임

- **하나 이상의 추상 메소드**를 가지고 있는 클래스
- **구현되지 않은 메소드를 포함**한 클래스는 무조건 추상 클래스
- ```abstract```와 ```final``` 키워드는 동시에 표기할 수 없다.
- **일반적인 메소드**를 포함하기도 한다.
- **일반 변수**를 가질 수 있다.
- **추상 클래스가 아닌 클래스**에서 상속받은 경우 **모든 추상 메소드를 구현**해주어야 한다.
- **추상 클래스에서 추상 클래스**를 상속받는 경우 **추상 메소드를 구현하지 않아**도 된다.
- **추상 클래스는 인스턴스화 할 수 없다.**
  - 하지만, 상속 받은 클래스를 통해 인스턴스화를 할 수 있다.
    ```java
    "AbstractClass" ab = new "ClassName"();
    ```
- 궁극적인 목적은 **상속** ```extends``` 이다.

### 1.1 구현
```java
abstract class Shape
{
  abstract void draw(); // 메소드 앞에 abstract가 있으면 추상 메소드이다.

  void hit (int x)
  {
    x = 3;
  };
}
```
***

## 2. 인터페이스 (Interface)

- **구현되지 않은 메소드 형태들의 집합**이다.
- **특정 인터페이스를 상속받는 클래스**는 반드시 **모든 메소드를 구현**해주어야 한다.
- ```final``` 키워드를 붙일 수 없고, 모든 변수는 ```static``` 이어야만 한다.
- **인터페이스**는 콤마(,)를 사용하여 **하나 이상의 인터페이스들을 상속**할 수 있다.
- **인터페이스 간의 상속**은 메소드 구현을 하지 않아도 되니 ```extends```를 사용한다.
- **인터페이스**는 생성자를 가질 수 없다.
- **추상 클래스 처럼 인스턴스화 할 수 없다.**
  - 하지만, 상속 받은 클래스를 통해 인스턴스화를 할 수 있다.
    ```java
    "InterfaceName" ab = new "ClassName"();
    ```
- 어떤 클래스가 **인터페이스를 상속**받을 때 ```implements``` 를 사용한다.

### 2.1 구현
```java
interface Shape
{
  void draw(); // 인터페이스에서는 abstract 생략이 가능하다.
  abstract void move(int y);
}
```

***
## 3. 차이점
- **추상 클래스**는 **인터페이스**보다 속도가 빠르다.
  - **인터페이스**는 관련 메소드들을 찾기위해 **부가적인 일**을 더 처리한다.
- **추상 클래스**는 모든 메소드를 ```abstract```로 정의해야 한다.
- **인터페이스**는 모든 변수를 상수 ```static final```로 정의해야 한다.
- **인터페이스**의 경우 변수 앞에 ```static final```, 메소드 앞에 ```abstract```의 생략이 가능하다.
  - 하지만, **코드의 가독성을 위해 적는 습관을 갖자**
***
## 4. 사용
  ### 4.1 추상 클래스
> 추상 클래스는 다음과 같은 상황에 쓰인다.
- **같은 종류나 행동**들을 구현할게 많을 때
- **상속에 대한 계층 구조**를 명확히 표현하고자 할 때
- **일반 메소드**와 **일반 변수**를 함께 쓸 수 있어 상황에 따라 편리하다.

  ### 4.2 인터페이스
> 인터페이스는 다음과 같은 상황에 쓰인다.
- **디자인을 구성하는 요소**들이 자주 바뀔 때
- **메소드 형태**만 **서로 공유**해서 구현되는 상황일 때
- **클래스 전체가 아닌 메소드**들만 쓰고 싶을 때
- **동시 개발**을 하여 시간을 단축하고자 할 때
  - **구현되지 않은 메소드** 부분에 대한 **비동기 처리** 가능
